package io.imulab.astrea.service

import com.fasterxml.jackson.annotation.JsonProperty
import com.typesafe.config.Config
import io.imulab.astrea.sdk.oauth.assertType
import io.imulab.astrea.sdk.oauth.error.InvalidGrant
import io.imulab.astrea.sdk.oauth.request.OAuthAuthorizeRequest
import io.imulab.astrea.sdk.oauth.request.OAuthRequest
import io.imulab.astrea.sdk.oauth.reserved.AuthenticationMethod
import io.imulab.astrea.sdk.oauth.reserved.dot
import io.imulab.astrea.sdk.oauth.token.storage.AccessTokenRepository
import io.imulab.astrea.sdk.oauth.token.storage.AuthorizeCodeRepository
import io.imulab.astrea.sdk.oauth.token.storage.RefreshTokenRepository
import io.imulab.astrea.sdk.oauth.token.strategy.AuthorizeCodeStrategy
import io.imulab.astrea.sdk.oidc.discovery.Discovery
import io.imulab.astrea.sdk.oidc.discovery.OidcContext
import io.imulab.astrea.sdk.oidc.jwk.JsonWebKeySetRepository
import io.imulab.astrea.sdk.oidc.jwk.JsonWebKeySetStrategy
import io.imulab.astrea.sdk.oidc.request.OidcAuthorizeRequest
import io.imulab.astrea.sdk.oidc.request.OidcSession
import io.imulab.astrea.sdk.oidc.request.OidcSessionRepository
import io.imulab.astrea.sdk.oidc.spi.HttpResponse
import io.imulab.astrea.sdk.oidc.spi.SimpleHttpClient
import io.imulab.astrea.service.RedisAuthorizeCodeRepository.PersistenceForm
import io.vertx.core.json.Json
import io.vertx.kotlin.redis.delAwait
import io.vertx.kotlin.redis.getAwait
import io.vertx.kotlin.redis.setWithOptionsAwait
import io.vertx.redis.RedisClient
import io.vertx.redis.op.SetOptions
import org.jose4j.jwk.JsonWebKeySet
import org.jose4j.keys.AesKey
import java.time.Duration
import java.time.LocalDateTime
import java.time.ZoneOffset
import java.util.*

class ServiceContext(config: Config, discovery: Discovery) : OidcContext, Discovery by discovery {
    override val idTokenLifespan: Duration = config.getDuration("service.idTokenLifespan")
    override val masterJsonWebKeySet: JsonWebKeySet = JsonWebKeySet(config.getString("service.jwks"))
    override val nonceEntropy: Int = config.getInt("service.nonceEntropy")
    override val issuerUrl: String = issuer
    override val authorizeEndpointUrl: String = authorizationEndpoint
    override val tokenEndpointUrl: String = tokenEndpoint
    override val defaultTokenEndpointAuthenticationMethod: String = AuthenticationMethod.clientSecretBasic
    override val authorizeCodeLifespan: Duration = config.getDuration("service.authorizeCodeLifespan")
    override val accessTokenLifespan: Duration = config.getDuration("service.accessTokenLifespan")
    override val refreshTokenLifespan: Duration = config.getDuration("service.refreshTokenLifespan")
    override val stateEntropy: Int = config.getInt("service.stateEntropy")

    val authorizeCodeKey = AesKey(Base64.getDecoder().decode(config.getString("service.authorizeCodeKey")))
    val refreshTokenKey = AesKey(Base64.getDecoder().decode(config.getString("service.refreshTokenKey")))

    override fun validate() {
        super<OidcContext>.validate()
    }
}

/**
 * Implementation of [AuthorizeCodeStrategy] to append a service id in front of the authorize code generated
 * by another [AuthorizeCodeStrategy]. The code is decorated so that the api gateway can distinguish between code
 * generated by different services. For instance, token request with code generated by the authorize code flow service
 * should only be routed back to the authorize code flow service, not the hybrid flow service, and vice versa.
 *
 * The format of the decoration is `$service_id.$code`.
 */
class ServiceAwareAuthorizeCodeStrategy(
    private val serviceId: String,
    private val delegate: AuthorizeCodeStrategy
) : AuthorizeCodeStrategy {

    override fun computeIdentifier(code: String): String =
        delegate.computeIdentifier(code.substringAfter(dot))

    override suspend fun generateCode(request: OAuthAuthorizeRequest): String =
        serviceId + dot + delegate.generateCode(request)

    override suspend fun verifyCode(code: String, request: OAuthAuthorizeRequest) {
        if (code.substringBefore(dot) != serviceId)
            throw InvalidGrant.invalid()
        delegate.verifyCode(code.substringAfter(dot), request)
    }
}

fun AuthorizeCodeStrategy.enableServiceAware(serviceId: String): AuthorizeCodeStrategy {
    return ServiceAwareAuthorizeCodeStrategy(serviceId, this)
}

/**
 * Redis implementation of [AuthorizeCodeRepository] and [OidcSessionRepository]. It uses an internal representation
 * [PersistenceForm] to save code sessions.
 *
 * This implementation uses a little hack to avoid implement both repositories individually. Because session data
 * in both repositories largely overlaps, this implementation does nothing when asked to perform
 * [OidcSessionRepository.createOidcSession] because it assumes [AuthorizeCodeRepository.createAuthorizeCodeSession]
 * is already invoked by a previous handler, and thus session is already created. Likewise, this implementation
 * does nothing when [AuthorizeCodeRepository.invalidateAuthorizeCodeSession] is invoked, because it assumes
 * [OidcSessionRepository.deleteOidcSession] will be invoked by a later handler. However, this assumption may be invalid
 * when the incoming request is not an OAuth only request, thus effectively skipping the later handler. In this case,
 * the handler caller should call [OidcSessionRepository.deleteOidcSession] explicitly just to be safe.
 */
class RedisAuthorizeCodeRepository(
    private val client: RedisClient,
    private val authorizeCodeLifespan: Duration
): AuthorizeCodeRepository, OidcSessionRepository {

    override suspend fun createAuthorizeCodeSession(code: String, request: OAuthRequest) {
        client.setWithOptionsAwait(
            code,
            Json.encode(PersistenceForm.fromRequest(request)),
            SetOptions().setEX(authorizeCodeLifespan.toMillis() / 1000)
        )
    }

    override suspend fun getAuthorizeCodeSession(code: String): OAuthRequest {
        val json = client.getAwait(code) ?: throw InvalidGrant.invalid()
        val decoded = Json.decodeValue(json, PersistenceForm::class.java)
        return decoded.toRequest()
    }

    override suspend fun invalidateAuthorizeCodeSession(code: String) {
        // do nothing because we will let the oidc handler
    }

    override suspend fun createOidcSession(authorizeCode: String, session: OidcSession) {
        // do nothing because oauth handler already created a session.
    }

    override suspend fun getOidcSession(authorizeCode: String): OidcSession {
        return getAuthorizeCodeSession(authorizeCode).session.assertType()
    }

    override suspend fun deleteOidcSession(authorizeCode: String) {
        client.delAwait(authorizeCode)
    }

    class PersistenceForm {
        @JsonProperty("1") var id: String = ""
        @JsonProperty("2") var requestTime: Long = 0
        @JsonProperty("3") var clientId: String = ""
        @JsonProperty("4") var scopes: Set<String> = emptySet()
        @JsonProperty("5") var subject: String = ""
        @JsonProperty("6") var acrValues: List<String> = emptyList()
        @JsonProperty("7") var accessTokenClaims: Map<String, Any> = emptyMap()
        @JsonProperty("8") var idTokenClaims: Map<String, Any> = emptyMap()
        @JsonProperty("9") var authTime: Long = 0
        @JsonProperty("10") var nonce: String = ""
        @JsonProperty("11") var redirectUri: String = ""

        fun toRequest(): OAuthRequest {
            return OidcAuthorizeRequest.Builder().also { b ->
                b.client = IdOnlyClient(clientId)
                b.nonce = nonce
                b.redirectUri = redirectUri
                b.session = OidcSession().also { s ->
                    s.subject = subject
                    s.acrValues.addAll(acrValues)
                    s.authTime = LocalDateTime.ofEpochSecond(authTime, 0, ZoneOffset.UTC)
                    s.nonce = nonce
                    s.accessTokenClaims.putAll(accessTokenClaims)
                    s.idTokenClaims.putAll(idTokenClaims)
                    s.grantedScopes.addAll(scopes)
                }
            }.build().also { r ->
                r.id = id
                r.requestTime = LocalDateTime.ofEpochSecond(requestTime, 0, ZoneOffset.UTC)
            }
        }

        companion object {
            fun fromRequest(req: OAuthRequest) : PersistenceForm {
                return PersistenceForm().apply {
                    id = req.id
                    requestTime = req.requestTime.toEpochSecond(ZoneOffset.UTC)
                    clientId = req.client.id
                    scopes = req.session.grantedScopes
                    subject = req.session.subject
                    accessTokenClaims = req.session.accessTokenClaims
                    acrValues = req.session.assertType<OidcSession>().acrValues
                    idTokenClaims = req.session.assertType<OidcSession>().idTokenClaims
                    authTime = req.session.assertType<OidcSession>().authTime?.toEpochSecond(ZoneOffset.UTC) ?: 0
                    nonce = req.session.assertType<OidcSession>().nonce
                    redirectUri = when (req) {
                        // todo: replace with effectiveRedirectUri call, assuming is already validated.
                        is OAuthAuthorizeRequest -> {
                            if (req.redirectUri.isEmpty())
                                req.client.redirectUris.first()
                            else
                                req.redirectUri
                        }
                        else -> ""
                    }
                }
            }
        }
    }
}

/**
 * NoOp implementation of [AccessTokenRepository]. Since we are implementing JWT bearer token type. There is no need
 * to save state for introspection.
 */
object NoOpAccessTokenRepository : AccessTokenRepository {
    override suspend fun createAccessTokenSession(token: String, request: OAuthRequest) {}
    override suspend fun getAccessTokenSession(token: String): OAuthRequest = notImplemented()
    override suspend fun deleteAccessTokenSession(token: String) {}
    override suspend fun deleteAccessTokenAssociatedWithRequest(requestId: String) {}
}

/**
 * Message publishing implementation of [RefreshTokenRepository]. When a refresh token is created, this repository
 * should broadcast relevant information which should be picked by a refresh token service.
 */
class PublishingRefreshTokenRepository : RefreshTokenRepository {
    override suspend fun createRefreshTokenSession(token: String, request: OAuthRequest) {
        // todo
    }
    override suspend fun getRefreshTokenSession(token: String): OAuthRequest = notImplemented()
    override suspend fun deleteRefreshTokenSession(token: String) = notImplemented()
    override suspend fun deleteRefreshTokenAssociatedWithRequest(requestId: String) = notImplemented()
}

/**
 * Extension to [JsonWebKeySetStrategy] to resolve all keys locally. Hence, client and repository are not really needed.
 */
class LocalJsonWebKeySetStrategy(serverJwks: JsonWebKeySet) : JsonWebKeySetStrategy(
    httpClient = object : SimpleHttpClient { override suspend fun get(url: String): HttpResponse = notImplemented() },
    jsonWebKeySetRepository = object : JsonWebKeySetRepository {
        override suspend fun getServerJsonWebKeySet(): JsonWebKeySet = serverJwks
        override suspend fun getClientJsonWebKeySet(jwksUri: String): JsonWebKeySet? = null
        override suspend fun writeClientJsonWebKeySet(jwksUri: String, keySet: JsonWebKeySet) {}
    }
)